<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" integrity="sha384-gfdkjb5BdAXd+lj+gudLWI+BXq4IuLW5IT+brZEZsLFm++aCMlF1V92rMkPaX4PP" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <style>
  body {
   
    background: linear-gradient(to bottom right, #000000, #2c3e50);
    color: aliceblue;
    }

    .center {
    display: block;
    margin-left: auto;
    margin-right: auto;
    width: 50%;
    }

    .col-lg-4 {
            text-align: center;
            padding-top: 15px;
    }

    .featurette-heading {
        text-align: center;
    }

    .lead{
        padding-left: 15px;
        padding-right: 15px;
    }
    

    @media screen and (max-width: 620px){
      .lead{
        text-align: center;
        padding: 0px;
      }
    }
  </style>
  <title>Description</title>
</head>

<body>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark ">
    <a class="navbar-brand" href="#">TEAM RASP</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon">
      </span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav justify-content-end ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="./index.html">About</a>
        </li>
        <li class="nav-item active">
          <a class="nav-link" href="./description.html">Description
            <span class="sr-only">(current)</span>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="./simulator.html">Simulator</a>
        </li>
        <li class="nav-item ">
          <a class="nav-link" href="./team details.html">Team</a>
        </li>
      </ul>
    </div>
  </nav>
  <!-- Objective -->
  <br>
  <h2 class="featurette-heading">Pseudocode</h2>
  <p class="lead">The following pseudocode shows the details of Dijkstra’s algorithm:</p>
  <!-- <p class="lead"><i><span style="color:red;">Note:</span> Dijkstra’s algorithm is only applicable when all weights are positive because, during the execution, the weights of the edges are added to find the shortest path.</i></p> -->
  <img class="center" src="./assets/pseudo.png" alt="pseudocode" width="500" height="600">
  <br>
  <br>
  <!-- Objective Over -->
  <h2 class="featurette-heading">Time Complexity
    <span class="text-muted">Analysis</span>
  </h2>
  <p class="lead">There are multiple ways we can implement this algorithm. Each way utilizes different data structures to store the graph, as well as the priority queue. Thus,
    <b>the differences between these implementations leads to different time complexities.</b>
  </p>
  <p class="lead">
    <span class="text-muted">
      <b>Case I:</b>
    </span>
  </p>
  <p class="lead">The given graph G=(V, E) is represented as an adjacency matrix. Here w[u, v] stores the weight of edge (u, v).</p>
  <p class="lead">
    <i>Let |E| and |V| be the number of edges and vertices in the graph, respectively. Then the time complexity is calculated:</i>
  </p>
  <ol>
    <li class="lead">Adding all |V| vertices to Q takes O(|V|) time.</li>
    <li class="lead">Removing the node with minimal dist takes O(|V|) time, and we only need O(1) to recalculate dist[u] and update Q. Since we use an adjacency matrix here, we’ll need to loop for |V| vertices to update the dist array.</li>
    <li class="lead">The time taken for each iteration of the loop is O(|V|), as one vertex is deleted from Q per loop.</li>
    <li class="lead">Thus, total time complexity becomes O(|V|) + O(|V|) x O(|V|) =
      <b>O(|V|^2).</b>
    </li>
  </ol>
  <br>
  <p class="lead">
    <span class="text-muted">
      <b>Case II:</b>
    </span>
  </p>
  <p class="lead">This case is valid when:</p>
  <ul>
    <li class="lead">The given graph G=(V, E) is represented as an adjacency list.</li>
    <li class="lead">The priority queue Q is represented as a binary heap or a Fibonacci heap.</li>
  </ul>
  <p class="lead">
    <i>time complexity using a binary heap</i>
  </p>
  <ol>
    <li class="lead">It takes O(|V|) time to construct the initial priority queue of |V| vertices.</li>
    <li class="lead">With adjacency list representation, all vertices of the graph can be traversed using BFS. Therefore, iterating over all vertices’ neighbors and updating their dist values over the course of a run of the algorithm takes O(|E|) time.</li>
    <li class="lead">The time taken for each iteration of the loop is O(|V|), as one vertex is removed from Q per loop.</li>
    <li class="lead">The binary heap data structure allows us to extract-min (remove the node with minimal dist) and update an element (recalculate dist[u]) in O(log|V|) time.</li>
    <li class="lead">Therefore, the time complexity becomes O(|V|) + O(|E| x log|V|) + O(|V| x log|V|), which is O((|E|+|V|) X log|V|) =
      <b>O(|E| x log|V|)</b>since |E| >= |V| - 1 as G is a connected graph.</li>
  </ol>
  <br>
  <!-- OUR PROJECT OVER -->
  <!-- Copyright -->
  <div class="text-center p-3" style="background-color: rgba(0, 0, 0, 0.2);">© 2022 Copyright: KJSCE</div>
  <!-- Copyright -->
</body>

</html>